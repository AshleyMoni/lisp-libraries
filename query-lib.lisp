(require 'match)

(defgeneric clear-db (db))
(defgeneric db-query (key db))
(defgeneric db-push (key db val))

(defvar *default-db* (make-hash-table))
(defmethod clear-db ((db hash-table))
  (clrhash db))
(defmethod db-query (key (db hash-table))
  (gethash key db))
(defmethod db-push (key db val)
  (setf (gethash key db)
     (push val (gethash key db))))
(defmacro fact (pred &rest args)
  `(progn (db-push ',pred *default-db* ',args)
	   ',args))

(defmacro with-db (db &rest r)
  `(let ((*default-db* ,db))
     ,@r))

(defvar *compile-queries* t)
(defmacro with-query (db query &body body)
  (if db
      `(with-db ,db
	 ,(if *compile-queries*
	      `(with-compiled-answer ,query ,@body)
	      `(with-interpreted-answer ,query ,@body)))
      (if *compile-queries*
	  `(with-compiled-answer ,query ,@body)
	  `(with-interpreted-answer ,query ,@body))))

(defmacro with-interpreted-answer (query &body body)
  (let ((binds (gensym)))
    `(dolist (,binds (interpret-query ',query))
       (let ,(mapcar #'(lambda (v)
                         `(,v (binding ',v ,binds)))
                     (vars-in query #'atom))
         ,@body))))
(defun interpret-query (expr &optional binds)
  (case (car expr)
    (and (interpret-and (reverse (cdr expr)) binds))
    (or (interpret-or (cdr expr) binds))
    (not (interpret-not (cadr expr) binds))
    (t (lookup (car expr) (cdr expr) binds))))
(defun interpret-and (clauses binds)
  (if (null clauses)
      (list binds)
    (mapcan #'(lambda (b)
		(interpret-query (car clauses) b))
	    (interpret-and (cdr clauses) binds))))
(defun interpret-or (clauses binds)
  (mapcan #'(lambda (c)
              (interpret-query c binds))
          clauses))
(defun interpret-not (clause binds)
  (if (interpret-query clause binds)
      nil
    (list binds)))
(defun lookup (pred args &optional binds)
  (mapcan #'(lambda (x)
              (aif* (match x args binds) (list it)))
          (db-query pred *default-db*)))

(defmacro with-compiled-answer (query &body body)
  `(with-gensyms ,(vars-in query #'simplep)
     ,(compile-query query `(progn ,@body))))
(defun compile-query (q body)
  (case (car q)
    (and (compile-and (cdr q) body))
    (or   (compile-or (cdr q) body))
    (not (compile-not (cadr q) body))
    (lisp `(if ,(cadr q) ,body))
    (t    (compile-simple q body))))
(defun compile-simple (q body)
  (let ((fact (gensym)))
    `(dolist (,fact (db-query ',(car q) *default-db*))
       (pat-match ,(cdr q) ,fact ,body nil))))
(defun compile-and (clauses body)
  (if (null clauses)
      body
      (compile-query (car clauses)
                     (compile-and (cdr clauses) body))))
(defun compile-or (clauses body)
  (if (null clauses)
      nil
      (let ((gbod (gensym))
            (vars (vars-in body #'simplep)))
        `(labels ((,gbod ,vars ,body))
           ,@(mapcar #'(lambda (cl)
                         (compile-query cl `(,gbod ,@vars)))
                     clauses)))))
(defun compile-not (q body)
  (let ((tag (gensym)))
    `(if (block ,tag
           ,(compile-query q `(return-from ,tag nil))
           t)
         ,body)))

(provide 'query)