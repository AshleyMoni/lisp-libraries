(require 'anaphora)

(defun destruc (pat seq &optional (atom? #'atom) (n 0))
  (if (null pat)
      nil
    (let ((rest (cond ((funcall atom? pat) pat)
		      ((eq (car pat) '&rest) (cadr pat))
		      ((eq (car pat) '&body) (cadr pat))
		      (t nil))))
      (if rest
	  `((,rest (subseq ,seq ,n)))
	(let ((p (car pat))
	      (rec (destruc (cdr pat) seq atom? (1+ n))))
	  (if (funcall atom? p)
	      (cons `(,p (elt ,seq ,n))
		    rec)
	    (let ((var (gensym)))
	      (cons (cons `(,var (elt ,seq ,n))
			  (destruc p var atom?))
		    rec))))))))
(defun dbind-ex (binds body)
  (if (null binds)
      `(progn ,@body)
    `(let ,(mapcar #'(lambda (b)
		       (if (consp (car b))
			   (car b)
			 b))
		   binds)
       ,(dbind-ex (mapcan #'(lambda (b)
			      (if (consp (car b))
				  (cdr b)))
			  binds)
		  body))))
(defmacro dbind (pat seq &body body)
  (let ((gseq (gensym)))
    `(let ((,gseq ,seq))
       ,(dbind-ex (destruc pat gseq #'atom) body))))

(defmacro with-array (pat ar &body body)
  (let ((gar (gensym)))
    `(let ((,gar ,ar))
       (let ,(mapcar #'(lambda (p)
                         `(,(car p) (aref ,gar ,@(cdr p))))
                     pat)
         ,@body))))


(defun varsymp (x)
  (and (symbolp x)
       (eq (char (symbol-name x) 0) #\?)
       (not (eq x '?))))
(defun binding (x binds)
  (labels ((recbind (x binds)
             (aif (assoc x binds)
                  (or (recbind (cdr it) binds)
                      it))))
    (let ((b (recbind x binds)))
      (values (cdr b) b))))
(defun match (x y &optional binds)
  (acond*
    ((or (eql x y) (eql x '?) (eql y '?)) (values binds t))
    ((binding x binds) (match it y binds))
    ((binding y binds) (match x it binds))
    ((varsymp x) (values (cons (cons x y) binds) t))
    ((varsymp y) (values (cons (cons y x) binds) t))
    ((and (consp x) (consp y) (match (car x) (car y) binds))
     (match (cdr x) (cdr y) it))
    (t (values nil nil))))

(defun vars-in (expr &optional (atom? #'atom))
  (if (funcall atom? expr)
      (if (varsymp expr) (list expr))
    (union (vars-in (car expr) atom?)
	   (vars-in (cdr expr) atom?))))
(defmacro if-match* (pat seq then &optional else)
  `(aif* (match ',pat ,seq)
         (let ,(mapcar #'(lambda (v)
                           `(,v (binding ',v it)))
                       (vars-in then #'atom))
           ,then)
         ,else))

(defmacro with-gensyms (syms &body body)
  `(let ,(mapcar #'(lambda (s)
		     `(,s (gensym)))
		 syms)
     ,@body))
(defun simplep (x) (or (atom x) (eq (car x) 'quote)))
(defun gensymp (s)
  (and (symbolp s) (not (symbol-package s))))
(defun length-test (pat rest)
  (let ((fin (caadar (last rest))))
    (if (or (consp fin) (eq fin 'elt))
	`(= (length ,pat) ,(length rest))
      `(> (length ,pat) ,(- (length rest) 2)))))
(defun match* (refs then else)
  (dbind ((pat expr) . rest) refs
	 (cond ((gensymp pat)
		`(let ((,pat ,expr))
		   (if (and (typep ,pat 'sequence)
			    ,(length-test pat rest))
		       ,then
		     ,else)))
	       ((eq pat '?) then)
	       ((varsymp pat)
		(let ((ge (gensym)))
		  `(let ((,ge ,expr))
		     (if (or (gensymp ,pat) (equal ,pat ,ge))
			 (let ((,pat ,ge)) ,then)
		       ,else))))
	       (t `(if (equal ,pat ,expr) ,then ,else)))))
(defun gen-match (refs then else)
  (if (null refs)
      then
    (let ((then (gen-match (cdr refs) then else)))
      (if (simplep (caar refs))
	  (match* refs then else)
	(gen-match (car refs) then else)))))
(defmacro pat-match (pat seq then else)
  (if (simplep pat)
      (match* `((,pat ,seq)) then else)
    (with-gensyms (gseq gelse)
		  `(labels ((,gelse () ,else))
		     ,(gen-match (cons (list gseq seq)
				       (destruc pat gseq #'simplep))
				 then
				 `(,gelse))))))
(defmacro if-match (pat seq then &optional else)
  `(let ,(mapcar #'(lambda (v) `(,v ',(gensym)))
		 (vars-in pat #'simplep))
     (pat-match ,pat ,seq ,then ,else)))

(provide 'match)